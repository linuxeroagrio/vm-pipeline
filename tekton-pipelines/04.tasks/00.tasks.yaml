apiVersion: v1
items:
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-06-19T16:32:55Z"
    generation: 8
    name: bootc-image-builder
    namespace: vm-pipelines
    resourceVersion: "14407260"
    uid: f78ac885-d8f5-4ad6-af1c-0676f97851c2
  spec:
    description: Builds bootc OS Image from config.toml
    params:
    - default: $(params.SOURCE_IMAGE_NAME)
      description: Reference of the source RHEL bootc image
      name: SOURCE_IMAGE
      type: string
    - default: $(params.SOURCE_IMAGE_TAG)
      description: Reference of the bootc image tag.
      name: SOURCE_IMAGE_TAG
      type: string
    - default: quay.io/centos-bootc/bootc-image-builder:latest
      description: The location of the buildah builder image.
      name: BUILDER_IMAGE
      type: string
    - default: qcow2
      description: Output format for the image
      name: DEST_FORMAT
      type: string
    - default: xfs
      description: Root File System Type
      name: ROOTFS_TYPE
      type: string
    - default: |
        [[customizations.user]]
        name = "admin"
        password = "admin"
        groups = ["wheel"]

        [[customizations.user]]
        name = "test"
        password = "test"
      description: config.toml content for customizations
      name: CONFIG_TOML_CONTENT
      type: string
    - default: ./config.toml
      description: config.toml file relative location to toml-workspace workspace.
        This takes precedence over the "CONFIG_TOML_CONTENT" parameter when toml-workspace
        workspace is mounted.
      name: WS_TOML_FILE
      type: string
    - default: "true"
      description: TLS Verification
      name: TLS_VERIFY
      type: string
    - default: ""
      description: AWS AMI Name
      name: AWS_AMI_NAME
      type: string
    - default: ""
      description: AWS S3 Bucket
      name: AWS_S3_BUCKET
      type: string
    - default: ""
      description: AWS S3 Region
      name: AWS_S3_REGION
      type: string
    steps:
    - computeResources: {}
      image: quay.io/podman/stable:latest
      name: bootc-image-builder
      script: |
        #!/usr/bin/env bash
        set -xe

        BUILD_COMMAND="--rootfs $(params.ROOTFS_TYPE) --type $(params.DEST_FORMAT) --tls-verify=$(params.TLS_VERIFY) $(params.SOURCE_IMAGE):$(params.SOURCE_IMAGE_TAG)"

        PODMAN_COMMAND="podman run \
        --device /dev/fuse:rw \
        --rm \
        -it \
        --privileged \
        --pull=newer \
        --security-opt label=type:unconfined_t \
        -v $(pwd)/output:/output \
        -v /root/.docker/config.json:/run/containers/0/auth.json \
        -v /var/lib/containers/storage:/var/lib/containers/storage"

        if [[ "$(workspaces.dockerconfig.bound)" == "true" ]]; then

          # if config.json exists at workspace root, we use that
          if test -f "$(workspaces.dockerconfig.path)/config.json"; then
            export DOCKER_CONFIG="$(workspaces.dockerconfig.path)"

          # else we look for .dockerconfigjson at the root
          elif test -f "$(workspaces.dockerconfig.path)/.dockerconfigjson"; then
            mkdir -p $HOME/.docker/
            cp "$(workspaces.dockerconfig.path)/.dockerconfigjson" "$HOME/.docker/config.json"
            export DOCKER_CONFIG="$HOME/.docker"

          # need to error out if neither files are present
          else
            echo "neither 'config.json' nor '.dockerconfigjson' found at workspace root"
            exit 1
          fi
        fi

        if [[ "$(params.DEST_FORMAT)" == "ami" ]]; then
          if [[ "$(workspaces.awscredentials.bound)" == "true" ]]; then
            if test -f "$(workspaces.awscredentials.path)/credentials"; then
              mkdir -p $HOME/.aws/
              cp "$(workspaces.awscredentials.path)/credentials" "$HOME/.aws/credentials"
              BUILD_COMMAND="--aws-ami-name $(params.AWS_AMI_NAME) --aws-bucket $(params.AWS_S3_BUCKET) --aws-region $(params.AWS_S3_REGION) $BUILD_COMMAND"
            else
              echo "AWS Credentials must be populated"
              exit 1
            fi
          fi
        fi

        if [[ "$(workspaces.toml-workspace.bound)" == "true" ]]; then
          if test -f "$(workspaces.toml-workspace.path)/$(params.WS_TOML_FILE)"; then
            cat $(workspaces.toml-workspace.path)/$(params.WS_TOML_FILE) > config.toml
            BUILD_COMMAND="--config /config.toml $BUILD_COMMAND"
            PODMAN_COMMAND="$PODMAN_COMMAND -v ./config.toml:/config.toml:ro"
          else
            echo "Toml file not found"
            exit 1
          fi
        else
          if [[ ! -z '$(params.CONFIG_TOML_CONTENT)' ]]; then
            echo '$(params.CONFIG_TOML_CONTENT)' > config.toml
            BUILD_COMMAND="--config /config.toml $BUILD_COMMAND"
            PODMAN_COMMAND="$PODMAN_COMMAND -v ./config.toml:/config.toml:ro"
          fi
        fi

        mkdir -p output

        podman pull $(params.SOURCE_IMAGE):$(params.SOURCE_IMAGE_TAG)

        $PODMAN_COMMAND \
        $(params.BUILDER_IMAGE) \
        $BUILD_COMMAND
      securityContext:
        capabilities:
          add:
          - SETFCAP
        privileged: true
      volumeMounts:
      - mountPath: /var/lib/containers
        name: varlibcontainers
      - mountPath: /dev/fuse
        name: fuse
      workingDir: $(workspaces.main-workspace.path)
    volumes:
    - emptyDir: {}
      name: varlibcontainers
    - hostPath:
        path: /dev/fuse
      name: fuse
    workspaces:
    - name: main-workspace
    - description: An optional workspace that allows providing a .docker/config.json
        file to access the container registry. The file should be placed at the root
        of the Workspace with name config.json or .dockerconfigjson.
      name: dockerconfig
      optional: true
    - description: AWS Credentials file to use for AMI Uploading
      name: awscredentials
      optional: true
    - description: An optional workspace that contains toml file
      name: toml-workspace
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      openshift.io/installed-from: Tektonhub
      tekton.dev/categories: Image Build
      tekton.dev/displayName: buildah
      tekton.dev/pipelines.minVersion: 0.50.0
      tekton.dev/platforms: linux/amd64,linux/s390x,linux/ppc64le,linux/arm64
      tekton.dev/tags: image-build
    creationTimestamp: "2025-06-19T01:32:11Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.9"
    name: buildah
    namespace: vm-pipelines
    resourceVersion: "10799485"
    uid: 218c8560-155a-4d1d-9953-93f1f3479ad2
  spec:
    description: |-
      Buildah task builds source into a container image and then pushes it to a container registry.
      Buildah Task builds source into a container image using Project Atomic's Buildah build tool.It uses Buildah's support for building from Dockerfiles, using its buildah bud command.This command executes the directives in the Dockerfile to assemble a container image, then pushes that image to a container registry.
    params:
    - description: Reference of the image buildah will produce.
      name: IMAGE
      type: string
    - default: quay.io/buildah/stable:v1
      description: The location of the buildah builder image.
      name: BUILDER_IMAGE
      type: string
    - default: overlay
      description: Set buildah storage driver
      name: STORAGE_DRIVER
      type: string
    - default: ./Dockerfile
      description: Path to the Dockerfile to build.
      name: DOCKERFILE
      type: string
    - default: .
      description: Path to the directory to use as context.
      name: CONTEXT
      type: string
    - default: "true"
      description: Verify the TLS on the registry endpoint (for push/pull to a non-TLS
        registry)
      name: TLSVERIFY
      type: string
    - default: oci
      description: The format of the built container, oci or docker
      name: FORMAT
      type: string
    - default: ""
      description: Extra parameters passed for the build command when building images.
        WARNING - must be sanitized to avoid command injection
      name: BUILD_EXTRA_ARGS
      type: string
    - default: ""
      description: Extra parameters passed for the push command when pushing images.
        WARNING - must be sanitized to avoid command injection
      name: PUSH_EXTRA_ARGS
      type: string
    - default: "false"
      description: Skip pushing the built image
      name: SKIP_PUSH
      type: string
    - default:
      - ""
      description: Dockerfile build arguments, array of key=value
      name: BUILD_ARGS
      type: array
    results:
    - description: Digest of the image just built.
      name: IMAGE_DIGEST
      type: string
    - description: Image repository where the built image would be pushed to
      name: IMAGE_URL
      type: string
    steps:
    - args:
      - $(params.BUILD_ARGS[*])
      computeResources: {}
      env:
      - name: PARAM_IMAGE
        value: $(params.IMAGE)
      - name: PARAM_STORAGE_DRIVER
        value: $(params.STORAGE_DRIVER)
      - name: PARAM_DOCKERFILE
        value: $(params.DOCKERFILE)
      - name: PARAM_CONTEXT
        value: $(params.CONTEXT)
      - name: PARAM_TLSVERIFY
        value: $(params.TLSVERIFY)
      - name: PARAM_FORMAT
        value: $(params.FORMAT)
      - name: PARAM_BUILD_EXTRA_ARGS
        value: $(params.BUILD_EXTRA_ARGS)
      - name: PARAM_PUSH_EXTRA_ARGS
        value: $(params.PUSH_EXTRA_ARGS)
      - name: PARAM_SKIP_PUSH
        value: $(params.SKIP_PUSH)
      image: $(params.BUILDER_IMAGE)
      name: build-and-push
      script: |
        BUILD_ARGS=()
        for buildarg in "$@"
        do
          BUILD_ARGS+=("--build-arg=$buildarg")
        done
        [ "$(workspaces.sslcertdir.bound)" = "true" ] && CERT_DIR_FLAG="--cert-dir=$(workspaces.sslcertdir.path)"
        [ "$(workspaces.dockerconfig.bound)" = "true" ] && DOCKER_CONFIG="$(workspaces.dockerconfig.path)" && export DOCKER_CONFIG
        # build the image (CERT_DIR_FLAG should be omitted if empty and BUILD_EXTRA_ARGS can contain multiple args)
        # shellcheck disable=SC2046,SC2086
        buildah ${CERT_DIR_FLAG} "--storage-driver=${PARAM_STORAGE_DRIVER}" bud "${BUILD_ARGS[@]}" ${PARAM_BUILD_EXTRA_ARGS} \
          "--format=${PARAM_FORMAT}" "--tls-verify=${PARAM_TLSVERIFY}" \
          -f "${PARAM_DOCKERFILE}" -t "${PARAM_IMAGE}" "${PARAM_CONTEXT}"
        [ "${PARAM_SKIP_PUSH}" = "true" ] && echo "Push skipped" && exit 0
        # push the image (CERT_DIR_FLAG should be omitted if empty and PUSH_EXTRA_ARGS can contain multiple args)
        # shellcheck disable=SC2046,SC2086
        buildah ${CERT_DIR_FLAG} "--storage-driver=${PARAM_STORAGE_DRIVER}" push \
          "--tls-verify=${PARAM_TLSVERIFY}" --digestfile /tmp/image-digest ${PARAM_PUSH_EXTRA_ARGS} \
          "${PARAM_IMAGE}" "docker://${PARAM_IMAGE}"
        tee "$(results.IMAGE_DIGEST.path)" < /tmp/image-digest
        printf '%s' "${PARAM_IMAGE}" | tee "$(results.IMAGE_URL.path)"
      securityContext:
        privileged: true
      volumeMounts:
      - mountPath: /var/lib/containers
        name: varlibcontainers
      workingDir: $(workspaces.source.path)
    volumes:
    - emptyDir: {}
      name: varlibcontainers
    workspaces:
    - name: source
    - name: sslcertdir
      optional: true
    - description: An optional workspace that allows providing a .docker/config.json
        file for Buildah to access the container registry. The file should be placed
        at the root of the Workspace with name config.json.
      name: dockerconfig
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      artifacthub.io/category: integration-delivery
      artifacthub.io/maintainers: |
        - name: KubeVirt Tekton tasks maintainers
          email: kubevirt-tekton-tasks@redhat.com
      artifacthub.io/provider: KubeVirt
      artifacthub.io/recommendations: |
        - url: https://kubevirt.io/
      tekton.dev/categories: Automation
      tekton.dev/displayName: KubeVirt cleanup VM
      tekton.dev/pipelines.minVersion: 0.43.0
      tekton.dev/platforms: linux/amd64,linux/s390x,linux/arm64
      tekton.dev/tags: kubevirt
    creationTimestamp: "2025-06-25T06:07:11Z"
    generation: 1
    labels:
      app.kubernetes.io/version: v0.24.0
    name: cleanup-vm
    namespace: vm-pipelines
    resourceVersion: "13619210"
    uid: 51e1bf9e-065c-4eac-82ba-c819e8a044db
  spec:
    description: Run commands in KubeVirt virtual machine. This task can stop and
      delete VMs
    params:
    - description: Name of a VM to execute the action in.
      name: vmName
      type: string
    - default: ""
      description: Namespace of a VM to execute the action in. (defaults to active
        namespace)
      name: vmNamespace
      type: string
    - default: "true"
      description: Stops the VM after executing the commands when set to true.
      name: stop
      type: string
    - default: "false"
      description: Deletes the VM after executing the commands when set to true.
      name: delete
      type: string
    - default: 30m
      description: Timeout for the command/script (includes potential VM start). The
        VM will be stopped or deleted accordingly once the timout expires. Should
        be in a 3h2m1s format.
      name: timeout
      type: string
    - default: __empty__
      description: Secret to use when connecting to a VM.
      name: secretName
      type: string
    - default: []
      description: Command to execute in a VM.
      name: command
      type: array
    - default: []
      description: Arguments of a command.
      name: args
      type: array
    - default: ""
      description: Script to execute in a VM.
      name: script
      type: string
    steps:
    - args:
      - --stop
      - $(params.stop)
      - --delete
      - $(params.delete)
      - --timeout
      - $(params.timeout)
      - --
      - $(params.command)
      - $(params.args)
      command:
      - entrypoint
      computeResources: {}
      env:
      - name: COMMAND
        value: execute-in-vm
      - name: VM_NAME
        value: $(params.vmName)
      - name: VM_NAMESPACE
        value: $(params.vmNamespace)
      - name: EXECUTE_SCRIPT
        value: $(params.script)
      - name: CONNECTION_SECRET_NAME
        value: $(params.secretName)
      image: quay.io/kubevirt/tekton-tasks:v0.24.0
      name: execute-in-vm
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault
      volumeMounts:
      - mountPath: /data/connectionsecret/
        name: connectionsecret
        readOnly: true
    volumes:
    - name: connectionsecret
      secret:
        optional: true
        secretName: $(params.secretName)
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      artifacthub.io/category: integration-delivery
      artifacthub.io/maintainers: |
        - name: KubeVirt Tekton tasks maintainers
          email: kubevirt-tekton-tasks@redhat.com
      artifacthub.io/provider: KubeVirt
      artifacthub.io/recommendations: |
        - url: https://kubevirt.io/
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1","kind":"Task","metadata":{"annotations":{"artifacthub.io/category":"integration-delivery","artifacthub.io/maintainers":"- name: KubeVirt Tekton tasks maintainers\n  email: kubevirt-tekton-tasks@redhat.com\n","artifacthub.io/provider":"KubeVirt","artifacthub.io/recommendations":"- url: https://kubevirt.io/\n","tekton.dev/categories":"Automation","tekton.dev/displayName":"KubeVirt create VM from manifest","tekton.dev/pipelines.minVersion":"0.43.0","tekton.dev/platforms":"linux/amd64","tekton.dev/tags":"kubevirt"},"labels":{"app.kubernetes.io/version":"v0.24.0"},"name":"create-vm-from-manifest","namespace":"vm-pipelines"},"spec":{"description":"Automates creation of the KubeVirt virtual machine. User can create VM from manifest or with the same parameters as for virtctl. It is possible to immediatelly start the vm after creation with startVM parameter.","params":[{"default":"","description":"YAML manifest of a VirtualMachine resource to be created.","name":"manifest","type":"string"},{"default":"","description":"Parameters for virtctl create vm command that will be used to create VirtualMachine.","name":"virtctl","type":"string"},{"default":"","description":"Namespace where to create the VM. (defaults to manifest namespace or active namespace)","name":"namespace","type":"string"},{"default":"","description":"Set to true or false to start / not start vm after creation. In case of runStrategy is set to Always, startVM flag is ignored.","name":"startVM","type":"string"},{"default":"","description":"Set runStrategy to VM. If runStrategy is set, vm.spec.running attribute is set to nil.","name":"runStrategy","type":"string"},{"default":"false","description":"Set owner reference to the new object created by the task run pod. Allowed values true/false","name":"setOwnerReference","type":"string"}],"results":[{"description":"The name of a VM that was created.","name":"name"},{"description":"The namespace of a VM that was created.","name":"namespace"}],"steps":[{"args":["--output=yaml"],"command":["create-vm"],"env":[{"name":"VM_MANIFEST","value":"$(params.manifest)"},{"name":"VM_NAMESPACE","value":"$(params.namespace)"},{"name":"VIRTCTL","value":"$(params.virtctl)"},{"name":"START_VM","value":"$(params.startVM)"},{"name":"SET_OWNER_REFERENCE","value":"$(params.setOwnerReference)"},{"name":"RUN_STRATEGY","value":"$(params.runStrategy)"},{"name":"POD_NAMESPACE","valueFrom":{"fieldRef":{"fieldPath":"metadata.namespace"}}},{"name":"POD_NAME","valueFrom":{"fieldRef":{"fieldPath":"metadata.name"}}}],"image":"quay.io/kubevirt/tekton-tasks:v0.24.0","name":"createvm"}]}}
      tekton.dev/categories: Automation
      tekton.dev/displayName: KubeVirt create VM from manifest
      tekton.dev/pipelines.minVersion: 0.43.0
      tekton.dev/platforms: linux/amd64
      tekton.dev/tags: kubevirt
    creationTimestamp: "2025-06-23T21:11:51Z"
    generation: 1
    labels:
      app.kubernetes.io/version: v0.24.0
    name: create-vm-from-manifest
    namespace: vm-pipelines
    resourceVersion: "12788197"
    uid: dc4c7299-2ae8-4108-95ef-a784a09f9137
  spec:
    description: Automates creation of the KubeVirt virtual machine. User can create
      VM from manifest or with the same parameters as for virtctl. It is possible
      to immediatelly start the vm after creation with startVM parameter.
    params:
    - default: ""
      description: YAML manifest of a VirtualMachine resource to be created.
      name: manifest
      type: string
    - default: ""
      description: Parameters for virtctl create vm command that will be used to create
        VirtualMachine.
      name: virtctl
      type: string
    - default: ""
      description: Namespace where to create the VM. (defaults to manifest namespace
        or active namespace)
      name: namespace
      type: string
    - default: ""
      description: Set to true or false to start / not start vm after creation. In
        case of runStrategy is set to Always, startVM flag is ignored.
      name: startVM
      type: string
    - default: ""
      description: Set runStrategy to VM. If runStrategy is set, vm.spec.running attribute
        is set to nil.
      name: runStrategy
      type: string
    - default: "false"
      description: Set owner reference to the new object created by the task run pod.
        Allowed values true/false
      name: setOwnerReference
      type: string
    results:
    - description: The name of a VM that was created.
      name: name
      type: string
    - description: The namespace of a VM that was created.
      name: namespace
      type: string
    steps:
    - args:
      - --output=yaml
      command:
      - create-vm
      computeResources: {}
      env:
      - name: VM_MANIFEST
        value: $(params.manifest)
      - name: VM_NAMESPACE
        value: $(params.namespace)
      - name: VIRTCTL
        value: $(params.virtctl)
      - name: START_VM
        value: $(params.startVM)
      - name: SET_OWNER_REFERENCE
        value: $(params.setOwnerReference)
      - name: RUN_STRATEGY
        value: $(params.runStrategy)
      - name: POD_NAMESPACE
        valueFrom:
          fieldRef:
            fieldPath: metadata.namespace
      - name: POD_NAME
        valueFrom:
          fieldRef:
            fieldPath: metadata.name
      image: quay.io/kubevirt/tekton-tasks:v0.24.0
      name: createvm
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-06-26T04:34:52Z"
    generation: 1
    name: customize-toml-file
    namespace: vm-pipelines
    resourceVersion: "14371408"
    uid: dcf12d04-dc94-438e-9f0b-13b753370205
  spec:
    description: Customize Kickstart Toml file
    params:
    - default: This is test user complete name
      description: Complete user name
      name: COMPLETE_USERNAME
      type: string
    - default: test-user
      description: Username
      name: USERNAME
      type: string
    - default: test-password
      description: User password
      name: USERPASS
      type: string
    - default: admin-password
      description: Admin user password
      name: ADMINPASS
      type: string
    - default: ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eZ8... user@host
      description: Admin user ssh public key
      name: ADMINSSHPUBKEY
      type: string
    - default: ./config.toml
      description: Relative path to toml file in toml-file-repo worskpace
      name: TOML_FILE_RELATIVE_CONTEXT
      type: string
    - default: quay.io/fedora/fedora:42
      description: OS image to be used
      name: OS_IMAGE
      type: string
    steps:
    - computeResources: {}
      image: $(params.OS_IMAGE)
      name: customize-toml-file
      script: |
        #!/usr/bin/env bash

        echo "Updating $(workspaces.toml-file-repo.path)/$(params.TOML_FILE_RELATIVE_CONTEXT) toml file"

        echo "Updating Complete username to $(params.COMPLETE_USERNAME)"
        sed -i 's/COMPLETEUSERNAME/$(params.COMPLETE_USERNAME)/g' $(params.TOML_FILE_RELATIVE_CONTEXT)

        echo "Updating Username to $(params.USERNAME)"
        sed -i 's/USERNAME/$(params.USERNAME)/g' $(params.TOML_FILE_RELATIVE_CONTEXT)

        echo "Updating User password to $(params.USERPASS)"
        sed -i 's/USERPASS/$(params.USERPASS)/g' $(params.TOML_FILE_RELATIVE_CONTEXT)

        echo "Updating admin password to $(params.ADMINPASS)"
        sed -i 's/ADMINPASS/$(params.ADMINPASS)/g' $(params.TOML_FILE_RELATIVE_CONTEXT)

        echo "Updating admin ssh public key to $(params.ADMINSSHPUBKEY)"
        sed -i 's/ADMINSSHPUBKEY/$(params.ADMINSSHPUBKEY)/g' $(params.TOML_FILE_RELATIVE_CONTEXT)

        echo "Printing updatd file"
        cat $(params.TOML_FILE_RELATIVE_CONTEXT)
      workingDir: $(workspaces.toml-file-repo.path)
    workspaces:
    - description: The repo that contains toml file to be processed
      name: toml-file-repo
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      artifacthub.io/category: integration-delivery
      artifacthub.io/maintainers: |
        - name: KubeVirt Tekton tasks maintainers
          email: kubevirt-tekton-tasks@redhat.com
      artifacthub.io/provider: KubeVirt
      artifacthub.io/recommendations: |
        - url: https://kubevirt.io/
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1","kind":"Task","metadata":{"annotations":{"artifacthub.io/category":"integration-delivery","artifacthub.io/maintainers":"- name: KubeVirt Tekton tasks maintainers\n  email: kubevirt-tekton-tasks@redhat.com\n","artifacthub.io/provider":"KubeVirt","artifacthub.io/recommendations":"- url: https://kubevirt.io/\n","tekton.dev/categories":"Automation","tekton.dev/displayName":"KubeVirt execute in vm","tekton.dev/pipelines.minVersion":"0.43.0","tekton.dev/platforms":"linux/amd64","tekton.dev/tags":"kubevirt"},"labels":{"app.kubernetes.io/version":"v0.24.0"},"name":"execute-in-vm","namespace":"vm-pipelines"},"spec":{"description":"Run commands in KubeVirt virtual machine.","params":[{"description":"Name of a VM to execute the action in.","name":"vmName","type":"string"},{"default":"","description":"Namespace of a VM to execute the action in. (defaults to active namespace)","name":"vmNamespace","type":"string"},{"default":"__empty__","description":"Secret to use when connecting to a VM.","name":"secretName","type":"string"},{"default":[],"description":"Command to execute in a VM.","name":"command","type":"array"},{"default":[],"description":"Arguments of a command.","name":"args","type":"array"},{"default":"","description":"Script to execute in a VM.","name":"script","type":"string"}],"steps":[{"args":["--","$(params.command)","$(params.args)"],"command":["entrypoint"],"env":[{"name":"COMMAND","value":"execute-in-vm"},{"name":"VM_NAME","value":"$(params.vmName)"},{"name":"VM_NAMESPACE","value":"$(params.vmNamespace)"},{"name":"EXECUTE_SCRIPT","value":"$(params.script)"},{"name":"CONNECTION_SECRET_NAME","value":"$(params.secretName)"}],"image":"quay.io/kubevirt/tekton-tasks:v0.24.0","name":"execute-in-vm","volumeMounts":[{"mountPath":"/data/connectionsecret/","name":"connectionsecret","readOnly":true}]}],"volumes":[{"name":"connectionsecret","secret":{"optional":true,"secretName":"$(params.secretName)"}}]}}
      tekton.dev/categories: Automation
      tekton.dev/displayName: KubeVirt execute in vm
      tekton.dev/pipelines.minVersion: 0.43.0
      tekton.dev/platforms: linux/amd64
      tekton.dev/tags: kubevirt
    creationTimestamp: "2025-06-23T23:35:28Z"
    generation: 1
    labels:
      app.kubernetes.io/version: v0.24.0
    name: execute-in-vm
    namespace: vm-pipelines
    resourceVersion: "12895376"
    uid: 468e416d-f69b-43ca-a9f9-00254068c2ac
  spec:
    description: Run commands in KubeVirt virtual machine.
    params:
    - description: Name of a VM to execute the action in.
      name: vmName
      type: string
    - default: ""
      description: Namespace of a VM to execute the action in. (defaults to active
        namespace)
      name: vmNamespace
      type: string
    - default: __empty__
      description: Secret to use when connecting to a VM.
      name: secretName
      type: string
    - default: []
      description: Command to execute in a VM.
      name: command
      type: array
    - default: []
      description: Arguments of a command.
      name: args
      type: array
    - default: ""
      description: Script to execute in a VM.
      name: script
      type: string
    steps:
    - args:
      - --
      - $(params.command)
      - $(params.args)
      command:
      - entrypoint
      computeResources: {}
      env:
      - name: COMMAND
        value: execute-in-vm
      - name: VM_NAME
        value: $(params.vmName)
      - name: VM_NAMESPACE
        value: $(params.vmNamespace)
      - name: EXECUTE_SCRIPT
        value: $(params.script)
      - name: CONNECTION_SECRET_NAME
        value: $(params.secretName)
      image: quay.io/kubevirt/tekton-tasks:v0.24.0
      name: execute-in-vm
      volumeMounts:
      - mountPath: /data/connectionsecret/
        name: connectionsecret
        readOnly: true
    volumes:
    - name: connectionsecret
      secret:
        optional: true
        secretName: $(params.secretName)
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-06-25T23:38:44Z"
    generation: 5
    name: generate-password
    namespace: vm-pipelines
    resourceVersion: "14281258"
    uid: 375c62d0-dd05-4d0f-a409-caa0f99167dd
  spec:
    description: Generates a password
    params:
    - default: "8"
      description: The user emial address
      name: PASSWORD_LENGTH
      type: string
    - default: A-Za-z0-9
      description: Characters filter
      name: CHAR_FILTER
      type: string
    - default: quay.io/fedora/fedora:42
      description: OS image to be used
      name: OS_IMAGE
      type: string
    results:
    - description: |
        Generated password string
      name: generated-password
      type: string
    steps:
    - computeResources: {}
      image: $(params.OS_IMAGE)
      name: generate-password
      script: |
        #!/usr/bin/env bash

        GENERATED_PASSWORD=$(tr -dc $(params.CHAR_FILTER) < /dev/urandom | head -c $(params.PASSWORD_LENGTH))
        echo "Generated password is: ${GENERATED_PASSWORD}"
        printf "%s" "${GENERATED_PASSWORD}" > "$(results.generated-password.path)"
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-07-01T20:18:09Z"
    generation: 3
    name: get-vm-vnc-access-info
    namespace: vm-pipelines
    resourceVersion: "16175701"
    uid: f8561138-b691-425a-8726-cf05ae629bad
  spec:
    description: Get the access info from virtual-desktop
    params:
    - description: The vnc user name
      name: USERNAME
      type: string
    - description: The vnc route namespace
      name: VNC_ROUTE_NAMESPACE
      type: string
    - default: quay.io/openshift/origin-cli:4.19
      description: oc cli image to be used
      name: OS_IMAGE
      type: string
    results:
    - description: |
        The username for vnc access
      name: vnc-username
      type: string
    - description: |
        The user password for vnc access
      name: vnc-userpass
      type: string
    - description: |
        The url access from vnc route
      name: vnc-url
      type: string
    steps:
    - computeResources: {}
      image: $(params.OS_IMAGE)
      name: remove-email-from-email
      script: |
        #!/usr/bin/env bash

        # Set the vnc user name
        echo "Setting vnc user name"
        printf "%s" "$(params.USERNAME)" > "$(results.vnc-username.path)"

        # Get the user password
        echo "Setting vnc user password"
        USERPASS=$(oc extract secret/$(params.USERNAME)-credentials-secret --confirm --to=-)
        if [ "${USERPASS}" == "" ]
        then
          echo "No vnc secret found"
          exit 1
        else
          printf "%s" "${USERPASS}" > "$(results.vnc-userpass.path)"
        fi

        # Get the route URL
        echo "Setting vnc url"
        VNC_URL=$(oc get routes -n $(params.VNC_ROUTE_NAMESPACE) $(params.USERNAME)-web-vnc -o jsonpath='{.spec.host}')
        if [ "${VNC_URL}" == "" ]
        then
          echo "No vnc url found"
          exit 1
        else
          printf "%s" "https://${VNC_URL}" > "$(results.vnc-url.path)"
        fi
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      openshift.io/installed-from: Tektonhub
      tekton.dev/categories: Git
      tekton.dev/displayName: git clone
      tekton.dev/pipelines.minVersion: 0.38.0
      tekton.dev/platforms: linux/amd64,linux/s390x,linux/ppc64le,linux/arm64
      tekton.dev/tags: git
    creationTimestamp: "2025-06-18T23:15:09Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.9"
    name: git-clone
    namespace: vm-pipelines
    resourceVersion: "10696418"
    uid: 06326adc-0e21-4535-840c-2b9e5c713ccf
  spec:
    description: |-
      These Tasks are Git tasks to work with repositories used by other tasks in your Pipeline.
      The git-clone Task will clone a repo from the provided url into the output Workspace. By default the repo will be cloned into the root of your Workspace. You can clone into a subdirectory by setting this Task's subdirectory param. This Task also supports sparse checkouts. To perform a sparse checkout, pass a list of comma separated directory patterns to this Task's sparseCheckoutDirectories param.
    params:
    - description: Repository URL to clone from.
      name: url
      type: string
    - default: ""
      description: Revision to checkout. (branch, tag, sha, ref, etc...)
      name: revision
      type: string
    - default: ""
      description: Refspec to fetch before checking out revision.
      name: refspec
      type: string
    - default: "true"
      description: Initialize and fetch git submodules.
      name: submodules
      type: string
    - default: "1"
      description: Perform a shallow clone, fetching only the most recent N commits.
      name: depth
      type: string
    - default: "true"
      description: Set the `http.sslVerify` global git config. Setting this to `false`
        is not advised unless you are sure that you trust your git remote.
      name: sslVerify
      type: string
    - default: ca-bundle.crt
      description: file name of mounted crt using ssl-ca-directory workspace. default
        value is ca-bundle.crt.
      name: crtFileName
      type: string
    - default: ""
      description: Subdirectory inside the `output` Workspace to clone the repo into.
      name: subdirectory
      type: string
    - default: ""
      description: Define the directory patterns to match or exclude when performing
        a sparse checkout.
      name: sparseCheckoutDirectories
      type: string
    - default: "true"
      description: Clean out the contents of the destination directory if it already
        exists before cloning.
      name: deleteExisting
      type: string
    - default: ""
      description: HTTP proxy server for non-SSL requests.
      name: httpProxy
      type: string
    - default: ""
      description: HTTPS proxy server for SSL requests.
      name: httpsProxy
      type: string
    - default: ""
      description: Opt out of proxying HTTP/HTTPS requests.
      name: noProxy
      type: string
    - default: "true"
      description: Log the commands that are executed during `git-clone`'s operation.
      name: verbose
      type: string
    - default: gcr.io/tekton-releases/github.com/tektoncd/pipeline/cmd/git-init:v0.40.2
      description: The image providing the git-init binary that this Task runs.
      name: gitInitImage
      type: string
    - default: /home/git
      description: |
        Absolute path to the user's home directory.
      name: userHome
      type: string
    results:
    - description: The precise commit SHA that was fetched by this Task.
      name: commit
      type: string
    - description: The precise URL that was fetched by this Task.
      name: url
      type: string
    - description: The epoch timestamp of the commit that was fetched by this Task.
      name: committer-date
      type: string
    steps:
    - computeResources: {}
      env:
      - name: HOME
        value: $(params.userHome)
      - name: PARAM_URL
        value: $(params.url)
      - name: PARAM_REVISION
        value: $(params.revision)
      - name: PARAM_REFSPEC
        value: $(params.refspec)
      - name: PARAM_SUBMODULES
        value: $(params.submodules)
      - name: PARAM_DEPTH
        value: $(params.depth)
      - name: PARAM_SSL_VERIFY
        value: $(params.sslVerify)
      - name: PARAM_CRT_FILENAME
        value: $(params.crtFileName)
      - name: PARAM_SUBDIRECTORY
        value: $(params.subdirectory)
      - name: PARAM_DELETE_EXISTING
        value: $(params.deleteExisting)
      - name: PARAM_HTTP_PROXY
        value: $(params.httpProxy)
      - name: PARAM_HTTPS_PROXY
        value: $(params.httpsProxy)
      - name: PARAM_NO_PROXY
        value: $(params.noProxy)
      - name: PARAM_VERBOSE
        value: $(params.verbose)
      - name: PARAM_SPARSE_CHECKOUT_DIRECTORIES
        value: $(params.sparseCheckoutDirectories)
      - name: PARAM_USER_HOME
        value: $(params.userHome)
      - name: WORKSPACE_OUTPUT_PATH
        value: $(workspaces.output.path)
      - name: WORKSPACE_SSH_DIRECTORY_BOUND
        value: $(workspaces.ssh-directory.bound)
      - name: WORKSPACE_SSH_DIRECTORY_PATH
        value: $(workspaces.ssh-directory.path)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND
        value: $(workspaces.basic-auth.bound)
      - name: WORKSPACE_BASIC_AUTH_DIRECTORY_PATH
        value: $(workspaces.basic-auth.path)
      - name: WORKSPACE_SSL_CA_DIRECTORY_BOUND
        value: $(workspaces.ssl-ca-directory.bound)
      - name: WORKSPACE_SSL_CA_DIRECTORY_PATH
        value: $(workspaces.ssl-ca-directory.path)
      image: $(params.gitInitImage)
      name: clone
      script: |
        #!/usr/bin/env sh
        set -eu

        if [ "${PARAM_VERBOSE}" = "true" ] ; then
          set -x
        fi

        if [ "${WORKSPACE_BASIC_AUTH_DIRECTORY_BOUND}" = "true" ] ; then
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.git-credentials" "${PARAM_USER_HOME}/.git-credentials"
          cp "${WORKSPACE_BASIC_AUTH_DIRECTORY_PATH}/.gitconfig" "${PARAM_USER_HOME}/.gitconfig"
          chmod 400 "${PARAM_USER_HOME}/.git-credentials"
          chmod 400 "${PARAM_USER_HOME}/.gitconfig"
        fi

        if [ "${WORKSPACE_SSH_DIRECTORY_BOUND}" = "true" ] ; then
          cp -R "${WORKSPACE_SSH_DIRECTORY_PATH}" "${PARAM_USER_HOME}"/.ssh
          chmod 700 "${PARAM_USER_HOME}"/.ssh
          chmod -R 400 "${PARAM_USER_HOME}"/.ssh/*
        fi

        if [ "${WORKSPACE_SSL_CA_DIRECTORY_BOUND}" = "true" ] ; then
           export GIT_SSL_CAPATH="${WORKSPACE_SSL_CA_DIRECTORY_PATH}"
           if [ "${PARAM_CRT_FILENAME}" != "" ] ; then
              export GIT_SSL_CAINFO="${WORKSPACE_SSL_CA_DIRECTORY_PATH}/${PARAM_CRT_FILENAME}"
           fi
        fi
        CHECKOUT_DIR="${WORKSPACE_OUTPUT_PATH}/${PARAM_SUBDIRECTORY}"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf ${CHECKOUT_DIR}" because ${CHECKOUT_DIR} might be "/"
          # or the root of a mounted volume.
          if [ -d "${CHECKOUT_DIR}" ] ; then
            # Delete non-hidden files and directories
            rm -rf "${CHECKOUT_DIR:?}"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "${CHECKOUT_DIR}"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "${CHECKOUT_DIR}"/..?*
          fi
        }

        if [ "${PARAM_DELETE_EXISTING}" = "true" ] ; then
          cleandir || true
        fi

        test -z "${PARAM_HTTP_PROXY}" || export HTTP_PROXY="${PARAM_HTTP_PROXY}"
        test -z "${PARAM_HTTPS_PROXY}" || export HTTPS_PROXY="${PARAM_HTTPS_PROXY}"
        test -z "${PARAM_NO_PROXY}" || export NO_PROXY="${PARAM_NO_PROXY}"

        git config --global --add safe.directory "${WORKSPACE_OUTPUT_PATH}"
        /ko-app/git-init \
          -url="${PARAM_URL}" \
          -revision="${PARAM_REVISION}" \
          -refspec="${PARAM_REFSPEC}" \
          -path="${CHECKOUT_DIR}" \
          -sslVerify="${PARAM_SSL_VERIFY}" \
          -submodules="${PARAM_SUBMODULES}" \
          -depth="${PARAM_DEPTH}" \
          -sparseCheckoutDirectories="${PARAM_SPARSE_CHECKOUT_DIRECTORIES}"
        cd "${CHECKOUT_DIR}"
        RESULT_SHA="$(git rev-parse HEAD)"
        EXIT_CODE="$?"
        if [ "${EXIT_CODE}" != 0 ] ; then
          exit "${EXIT_CODE}"
        fi
        RESULT_COMMITTER_DATE="$(git log -1 --pretty=%ct)"
        printf "%s" "${RESULT_COMMITTER_DATE}" > "$(results.committer-date.path)"
        printf "%s" "${RESULT_SHA}" > "$(results.commit.path)"
        printf "%s" "${PARAM_URL}" > "$(results.url.path)"
      securityContext:
        runAsNonRoot: true
        runAsUser: 65532
    workspaces:
    - description: The git repo will be cloned onto the volume backing this Workspace.
      name: output
    - description: |
        A .ssh directory with private key, known_hosts, config, etc. Copied to
        the user's home before git commands are executed. Used to authenticate
        with the git remote when performing the clone. Binding a Secret to this
        Workspace is strongly recommended over other volume types.
      name: ssh-directory
      optional: true
    - description: |
        A Workspace containing a .gitconfig and .git-credentials file. These
        will be copied to the user's home before any git commands are run. Any
        other files in this Workspace are ignored. It is strongly recommended
        to use ssh-directory over basic-auth whenever possible and to bind a
        Secret to this Workspace over other volume types.
      name: basic-auth
      optional: true
    - description: |
        A workspace containing CA certificates, this will be used by Git to
        verify the peer with when fetching or pushing over HTTPS.
      name: ssl-ca-directory
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-06-30T19:02:17Z"
    generation: 1
    name: helm-cli
    namespace: vm-pipelines
    resourceVersion: "15741402"
    uid: c7c973f9-32db-4f8d-88d3-09096a721c86
  spec:
    description: Provides Helm CLI
    params:
    - description: The Arguments to be passed to helm command.
      name: ARGS
      type: string
    - default: quay.io/linuxeroagrio/helm:4.19
      description: Helm image to be used
      name: VIRTCTL_IMAGE
      type: string
    steps:
    - computeResources: {}
      image: $(params.VIRTCTL_IMAGE)
      name: helm-cli
      script: |
        #!/usr/bin/env bash
        helm $(params.ARGS)
      workingDir: $(workspaces.objects.path)
    workspaces:
    - name: objects
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      openshift.io/installed-from: Tektonhub
      tekton.dev/categories: Deployment
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/platforms: linux/amd64,linux/s390x,linux/ppc64le,linux/arm64
      tekton.dev/tags: helm
    creationTimestamp: "2025-06-27T00:40:42Z"
    generation: 2
    labels:
      app.kubernetes.io/version: "0.3"
    name: helm-upgrade-from-repo
    namespace: vm-pipelines
    resourceVersion: "14808338"
    uid: 5c37a104-9a54-487b-8018-b150137bf610
  spec:
    description: These tasks will install / upgrade a helm chart into your Kubernetes
      / OpenShift Cluster using Helm
    params:
    - description: Specify a specific helm repo
      name: helm_repo
      type: string
    - description: Specify chart name that will be deployed
      name: chart_name
      type: string
    - default: v1.0.0
      description: The helm release version in semantic versioning format
      name: release_version
      type: string
    - default: helm-release
      description: The helm release name
      name: release_name
      type: string
    - default: ""
      description: The helm release namespace
      name: release_namespace
      type: string
    - default: ""
      description: 'Specify the values you want to overwrite, comma separated: autoscaling.enabled=true,replicas=1'
      name: overwrite_values
      type: string
    - default: docker.io/lachlanevenson/k8s-helm@sha256:0a068ae407e21d1836c6a89a1e9e81af1e55fa56890998e33d5caabdbb51e77b
      description: Specify a specific helm image
      name: helm_image
      type: string
    steps:
    - computeResources: {}
      image: $(params.helm_image)
      name: upgrade-from-repo
      script: |
        echo current installed helm releases
        helm list --namespace "$(params.release_namespace)"
        echo parsing helms repo name...
        REPO=`echo "$(params.chart_name)" | cut -d "/" -f 1`
        echo adding helm repo...
        helm repo add $REPO "$(params.helm_repo)"
        echo adding updating repo...
        helm repo update
        echo installing helm chart...
        helm upgrade --install --namespace "$(params.release_namespace)" $(params.release_name) $(params.chart_name) --debug --set "$(params.overwrite_values)"
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-06-19T06:11:12Z"
    generation: 1
    name: kics-scan
    namespace: vm-pipelines
    resourceVersion: "11008801"
    uid: 85ccd08d-d0f3-483a-af8f-9eeae0e27191
  spec:
    params:
    - default: ""
      description: Path to scan
      name: PATH_TO_SCAN
      type: string
    steps:
    - computeResources: {}
      image: docker.io/checkmarx/kics:ubi8
      name: scan
      script: |
        if [[ -f $(workspaces.source.path)/$(params.PATH_TO_SCAN) || -d $(workspaces.source.path)/$(params.PATH_TO_SCAN) ]]; then
          /app/bin/kics scan -p $(workspaces.source.path)/$(params.PATH_TO_SCAN) -o $(workspaces.source.path)/iac-scan-result -v --report-formats "html" --ignore-on-exit "results"
        else
          echo "Unable to find $(workspaces.source.path)/$(params.PATH_TO_SCAN) file or directory"
          exit 1
        fi
      workingDir: $(workspaces.source.path)
    workspaces:
    - name: source
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-07-01T19:09:51Z"
    generation: 1
    name: net-tools
    namespace: vm-pipelines
    resourceVersion: "16120519"
    uid: a655774a-08d3-4d32-8ed1-96ed8e73a5db
  spec:
    description: Provides net tools
    params:
    - description: The Arguments to be passed.
      name: ARGS
      type: string
    - default: image-registry.openshift-image-registry.svc:5000/openshift/network-tools:latest
      description: Image to be used
      name: NETTOOLS_IMAGE
      type: string
    steps:
    - computeResources: {}
      image: $(params.NETTOOLS_IMAGE)
      name: net-tools
      script: |
        #!/usr/bin/env bash
        $(params.ARGS)
      workingDir: $(workspaces.objects.path)
    workspaces:
    - name: objects
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      openshift.io/installed-from: Tektonhub
      tekton.dev/categories: Openshift
      tekton.dev/displayName: openshift client
      tekton.dev/pipelines.minVersion: 0.17.0
      tekton.dev/platforms: linux/amd64
      tekton.dev/tags: cli
    creationTimestamp: "2025-06-23T19:08:20Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.2"
    name: openshift-client
    namespace: vm-pipelines
    resourceVersion: "12695533"
    uid: 8216fd60-46e9-438c-a91b-f0c4e5207050
  spec:
    description: |-
      This task runs commands against the cluster provided by user and if not provided then where the Task is being executed.
      OpenShift is a Kubernetes distribution from Red Hat which provides oc, the OpenShift CLI that complements kubectl for simplifying deployment and configuration applications on OpenShift.
    params:
    - default: oc help
      description: The OpenShift CLI arguments to run
      name: SCRIPT
      type: string
    - default: "4.7"
      description: The OpenShift Version to use
      name: VERSION
      type: string
    steps:
    - computeResources: {}
      image: quay.io/openshift/origin-cli:$(params.VERSION)
      name: oc
      script: |
        #!/usr/bin/env bash

        [[ "$(workspaces.manifest-dir.bound)" == "true" ]] && \
        cd $(workspaces.manifest-dir.path)

        [[ "$(workspaces.kubeconfig-dir.bound)" == "true" ]] && \
        [[ -f $(workspaces.kubeconfig-dir.path)/kubeconfig ]] && \
        export KUBECONFIG=$(workspaces.kubeconfig-dir.path)/kubeconfig

        $(params.SCRIPT)
    workspaces:
    - description: The workspace which contains kubernetes manifests which we want
        to apply on the cluster.
      name: manifest-dir
      optional: true
    - description: The workspace which contains the the kubeconfig file if in case
        we want to run the oc command on another cluster.
      name: kubeconfig-dir
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      tekton.dev/categories: Developer Tools
      tekton.dev/displayName: ssh remote commands
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/platforms: linux/amd64
      tekton.dev/tags: ssh, ssh remote
    creationTimestamp: "2025-06-30T23:31:13Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.1"
    name: remote-ssh-commands
    namespace: vm-pipelines
    resourceVersion: "15943616"
    uid: b90e688a-da43-4952-aaf4-c7126c5c3828
  spec:
    description: |-
      The following task can be used to execute commands on remote machine.
      The following task takes host and required credentials as input along with the script and execute them on respective host machine and produce the output.
    params:
    - description: Remote host to connect
      name: HOST
      type: string
    - description: SSH username
      name: USERNAME
      type: string
    - default: "22"
      description: SSH port, default is 22
      name: PORT
      type: string
    - description: The script which you want to execute on remote server
      name: SSH_SCRIPT
      type: string
    - default: "false"
      description: include more ciphers with use_insecure_cipher
      name: USE_INSECURE_CIPHER
      type: string
    steps:
    - computeResources: {}
      image: docker.io/appleboy/drone-ssh:1.6.1@sha256:8252f5232316d832e14f259ed7b217d8d5f620d4668419d88ed47e1a48c0896a
      name: ssh
      script: |2

        export script="$(params.SSH_SCRIPT)"
        cmd=""
        [[ -f ./privatekey ]] && cmd="$cmd -i ./privatekey"
        [[ -f ./password ]] && cmd="$cmd -P $(cat ./password)"
        [[ -f ./passphrase ]] && cmd="$cmd --ssh-passphrase $(cat ./passphrase)"
        [[ -f ./fingerprint ]] && cmd="$cmd --fingerprint $(cat ./fingerprint)"
        [[ -f ./ciphers ]] && cmd="$cmd --ciphers $(cat ./ciphers)"
        [[ $(params.USE_INSECURE_CIPHER) == "true" ]] && cmd="$cmd --useInsecureCipher true"

        drone-ssh -H $(params.HOST) -p $(params.PORT) -u $(params.USERNAME) -s "$script" $cmd
      workingDir: $(workspaces.credentials.path)
    workspaces:
    - description: The workspace contains secrets can be used to authenticate with
        the HOST.
      name: credentials
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-06-25T22:22:56Z"
    generation: 10
    name: remove-domain-from-email
    namespace: vm-pipelines
    resourceVersion: "14274687"
    uid: 876abc41-b293-4e9f-b82f-a0e35de961a0
  spec:
    description: Upload a disk image for use in vm
    params:
    - description: The user emial address
      name: EMAIL
      type: string
    - default: quay.io/fedora/fedora:42
      description: OS image to be used
      name: OS_IMAGE
      type: string
    results:
    - description: |
        name from email
      name: username
      type: string
    steps:
    - computeResources: {}
      image: $(params.OS_IMAGE)
      name: remove-email-from-email
      script: |
        #!/usr/bin/env bash

        #Validate email structure
        EMAIL="$(params.EMAIL)"
        echo "$EMAIL"
        regex="^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
        if [[ $EMAIL =~ $regex ]]; then
          #Separate username
          echo "Valid email format"
          USERNAME="${EMAIL%@*}"
          echo "The username from e-mail ${EMAIL} is: ${USERNAME}"
          printf "%s" "${USERNAME}" > "$(results.username.path)"
        else
          echo "Invalid email format"
          exit 1
        fi
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      tekton.dev/categories: Messaging
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/platforms: linux/amd64,linux/s390x,linux/ppc64le
      tekton.dev/tags: messaging
    creationTimestamp: "2025-06-25T00:15:20Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.1"
    name: send-to-telegram
    namespace: vm-pipelines
    resourceVersion: "13418794"
    uid: 87c6c289-9f04-45b9-93e2-19bdb34dca03
  spec:
    description: |-
      These tasks post a simple message to a telegram chat.
      This task uses the Bot API of telegram to send a message.
    params:
    - description: Token of the bot through
      name: bot-token-secret
      type: string
    - description: ID of the chat to send the message towards
      name: chat-id
      type: string
    - description: The message to notify about
      name: message
      type: string
    steps:
    - computeResources: {}
      env:
      - name: BOT_TOKEN
        valueFrom:
          secretKeyRef:
            key: token
            name: $(params.bot-token-secret)
      - name: CHAT_ID
        value: $(params.chat-id)
      - name: MESSAGE
        value: $(params.message)
      image: docker.io/curlimages/curl:7.70.0@sha256:031df77a11e5edded840bc761a845eab6e3c2edee22669fb8ad6d59484b6a1c4
      name: post
      script: |
        #!/bin/sh
        MESSAGE=`echo $MESSAGE | sed -e 's/\"/\\\\"/g'`
        JSON="{\"chat_id\": ${CHAT_ID}, \"text\": \"${MESSAGE}\" }"
        curl -X POST -H 'Content-Type: application/json' -d "${JSON}" https://api.telegram.org/bot${BOT_TOKEN}/sendMessage
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      artifacthub.io/category: integration-delivery
      artifacthub.io/maintainers: |
        - name: OpenShift Pipeline task maintainers
          email: pipelines-extcomm@redhat.com
      artifacthub.io/provider: Red Hat
      artifacthub.io/recommendations: |
        - url: https://tekton.dev/
      tekton.dev/categories: containers
      tekton.dev/pipelines.minVersion: 0.41.0
      tekton.dev/source: https://github.com/openshift-pipelines/task-containers
      tekton.dev/tags: containers
    creationTimestamp: "2025-06-24T22:59:43Z"
    generation: 1
    labels:
      app.kubernetes.io/version: 0.4.0
    name: skopeo-copy
    namespace: vm-pipelines
    resourceVersion: "13362267"
    uid: 1a34928d-3481-471d-b475-5dd508f76528
  spec:
    description: "Skopeo is a command line tool for working with remote image registries.\nSkopeo
      doesnt require a daemon to be running while performing its operations. In particular,\nthe
      handy skopeo command called copy will ease the whole image copy operation. \nThe
      copy command will take care of copying the image from internal.registry to production.registry.\nIf
      your production registry requires credentials to login in order to push the
      image, skopeo can handle that as well.\nAfter copying the source and destination
      images SHA256 digest is stored as results.\n"
    params:
    - description: |
        Fully qualified source container image name, including tag, to be copied
        into `DESTINATION_IMAGE_URL` param.
      name: SOURCE_IMAGE_URL
      type: string
    - description: |
        Fully qualified destination container image name, including tag.
      name: DESTINATION_IMAGE_URL
      type: string
    - default: "true"
      description: |
        Sets the TLS verification flags for the source registry, `true` is recommended.
      name: SRC_TLS_VERIFY
      type: string
    - default: "true"
      description: |
        Sets the TLS verification flags for the destination registry, `true` is recommended.
      name: DEST_TLS_VERIFY
      type: string
    - default: "false"
      description: |
        Shows a more verbose (debug) output.
      name: VERBOSE
      type: string
    results:
    - description: |
        Source image SHA256 digest.
      name: SOURCE_DIGEST
      type: string
    - description: |
        Destination image SHA256 digest.
      name: DESTINATION_DIGEST
      type: string
    stepTemplate:
      computeResources: {}
      env:
      - name: PARAMS_SOURCE_IMAGE_URL
        value: $(params.SOURCE_IMAGE_URL)
      - name: PARAMS_DESTINATION_IMAGE_URL
        value: $(params.DESTINATION_IMAGE_URL)
      - name: PARAMS_SRC_TLS_VERIFY
        value: $(params.SRC_TLS_VERIFY)
      - name: PARAMS_DEST_TLS_VERIFY
        value: $(params.DEST_TLS_VERIFY)
      - name: PARAMS_VERBOSE
        value: $(params.VERBOSE)
      - name: WORKSPACES_IMAGES_URL_BOUND
        value: $(workspaces.images_url.bound)
      - name: WORKSPACES_IMAGES_URL_PATH
        value: $(workspaces.images_url.path)
      - name: RESULTS_SOURCE_DIGEST_PATH
        value: $(results.SOURCE_DIGEST.path)
      - name: RESULTS_DESTINATION_DIGEST_PATH
        value: $(results.DESTINATION_DIGEST.path)
    steps:
    - computeResources: {}
      image: registry.access.redhat.com/ubi8/skopeo:8.10-5
      name: skopeo-copy
      script: |
        set -e
        echo "/scripts/buildah-bud.sh"
        echo "/scripts/buildah-common.sh"
        echo "/scripts/common.sh"
        printf '%s' "IyEvdXNyL2Jpbi9lbnYgYmFzaAoKIyB0ZWt0b24ncyBob21lIGRpcmVjdG9yeQpkZWNsYXJlIC1yeCBURUtUT05fSE9NRT0iJHtURUtUT05fSE9NRTotL3Rla3Rvbi9ob21lfSIKCiMKIyBGdW5jdGlvbnMKIwoKZnVuY3Rpb24gZmFpbCgpIHsKICAgIGVjaG8gIkVSUk9SOiAkeyp9IiAyPiYxCiAgICBleGl0IDEKfQoKZnVuY3Rpb24gcGhhc2UoKSB7CiAgICBlY2hvICItLS0+IFBoYXNlOiAkeyp9Li4uIgp9CgojIGFzc2VydCBsb2NhbCB2YXJpYWJsZXMgYXJlIGV4cG9yZXRlZCBvbiB0aGUgZW52aXJvbm1lbnQKZnVuY3Rpb24gZXhwb3J0ZWRfb3JfZmFpbCgpIHsKICAgIGRlY2xhcmUgLWEgX3JlcXVpcmVkX3ZhcnM9IiR7QH0iCgogICAgZm9yIHYgaW4gJHtfcmVxdWlyZWRfdmFyc1tAXX07IGRvCiAgICAgICAgW1sgLXogIiR7IXZ9IiBdXSAmJgogICAgICAgICAgICBmYWlsICInJHt2fScgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCEiCiAgICBkb25lCgogICAgcmV0dXJuIDAKfQo=" |base64 -d >"/scripts/common.sh"
        echo "/scripts/s2i-build.sh"
        echo "/scripts/s2i-common.sh"
        echo "/scripts/s2i-generate.sh"
        echo "/scripts/skopeo-common.sh"
        printf '%s' "IyEvdXNyL2Jpbi9lbnYgYmFzaAoKZGVjbGFyZSAtcnggUEFSQU1TX1NPVVJDRV9JTUFHRV9VUkw9IiR7UEFSQU1TX1NPVVJDRV9JTUFHRV9VUkw6LX0iCmRlY2xhcmUgLXJ4IFBBUkFNU19ERVNUSU5BVElPTl9JTUFHRV9VUkw9IiR7UEFSQU1TX0RFU1RJTkFUSU9OX0lNQUdFX1VSTDotfSIKZGVjbGFyZSAtcnggUEFSQU1TX1NSQ19UTFNfVkVSSUZZPSIke1BBUkFNU19TUkNfVExTX1ZFUklGWTotfSIKZGVjbGFyZSAtcnggUEFSQU1TX0RFU1RfVExTX1ZFUklGWT0iJHtQQVJBTVNfREVTVF9UTFNfVkVSSUZZOi19IgpkZWNsYXJlIC1yeCBQQVJBTVNfVkVSQk9TRT0iJHtQQVJBTVNfVkVSQk9TRTotfSIKCmRlY2xhcmUgLXJ4IFdPUktTUEFDRVNfSU1BR0VTX1VSTF9QQVRIPSIke1dPUktTUEFDRVNfSU1BR0VTX1VSTF9QQVRIOi19IgpkZWNsYXJlIC1yeCBXT1JLU1BBQ0VTX0lNQUdFU19VUkxfQk9VTkQ9IiR7V09SS1NQQUNFU19JTUFHRVNfVVJMX0JPVU5EOi19IgoKZGVjbGFyZSAtcnggUkVTVUxUU19TT1VSQ0VfRElHRVNUX1BBVEg9IiR7UkVTVUxUU19TT1VSQ0VfRElHRVNUX1BBVEg6LX0iCmRlY2xhcmUgLXJ4IFJFU1VMVFNfREVTVElOQVRJT05fRElHRVNUX1BBVEg9IiR7UkVTVUxUU19ERVNUSU5BVElPTl9ESUdFU1RfUEFUSDotfSIKCiMKIyBBc3NlcnRpbmcgRW52aXJvbm1lbnQKIwoKZXhwb3J0ZWRfb3JfZmFpbCBcCiAgICBQQVJBTVNfU09VUkNFX0lNQUdFX1VSTCBcCiAgICBQQVJBTVNfREVTVElOQVRJT05fSU1BR0VfVVJMIFwKICAgIFJFU1VMVFNfU09VUkNFX0RJR0VTVF9QQVRIIFwKICAgIFJFU1VMVFNfREVTVElOQVRJT05fRElHRVNUX1BBVEgKICAgICAKCiMKIyBTa29wZW8gQXV0aGVudGljYXRpb24KIwoKZGVjbGFyZSAteCBSRUdJU1RSWV9BVVRIX0ZJTEU9IiIKCmRvY2tlcl9jb25maWc9IiR7SE9NRX0vLmRvY2tlci9jb25maWcuanNvbiIKaWYgW1sgLWYgIiR7ZG9ja2VyX2NvbmZpZ30iIF1dOyB0aGVuCiAgICBwaGFzZSAiU2V0dGluZyBSRUdJU1RSWV9BVVRIX0ZJTEUgdG8gJyR7ZG9ja2VyX2NvbmZpZ30nIgogICAgUkVHSVNUUllfQVVUSF9GSUxFPSR7ZG9ja2VyX2NvbmZpZ30KZmkKCiMKIyBWZXJib3NlIE91dHB1dAojCgpkZWNsYXJlIC14IFNLT1BFT19ERUJVR19GTEFHPSIiCgppZiBbWyAiJHtQQVJBTVNfVkVSQk9TRX0iID09ICJ0cnVlIiBdXTsgdGhlbgogICAgU0tPUEVPX0RFQlVHX0ZMQUc9Ii0tZGVidWciCiAgICBzZXQgLXgKZmkK" |base64 -d >"/scripts/skopeo-common.sh"
        echo "/scripts/skopeo-copy.sh"
        printf '%s' "IyEvdXNyL2Jpbi9lbnYgYmFzaAoKc2hvcHQgLXMgaW5oZXJpdF9lcnJleGl0CnNldCAtZXUgLW8gcGlwZWZhaWwKCnNvdXJjZSAiJChkaXJuYW1lICIke0JBU0hfU09VUkNFWzBdfSIpL2NvbW1vbi5zaCIKc291cmNlICIkKGRpcm5hbWUgIiR7QkFTSF9TT1VSQ0VbMF19Iikvc2tvcGVvLWNvbW1vbi5zaCIKCnBoYXNlICJDb3B5aW5nICcke1BBUkFNU19TT1VSQ0VfSU1BR0VfVVJMfScgaW50byAnJHtQQVJBTVNfREVTVElOQVRJT05fSU1BR0VfVVJMfSciCgpzZXQgLXgKCmlmIFsgLW4gIiR7UEFSQU1TX1NPVVJDRV9JTUFHRV9VUkx9IiBdICYmIFsgLW4gIiR7UEFSQU1TX0RFU1RJTkFUSU9OX0lNQUdFX1VSTH0iIF07IHRoZW4KICAgIHNrb3BlbyBjb3B5ICIke1NLT1BFT19ERUJVR19GTEFHfSIgXAogICAgICAgIC0tc3JjLXRscy12ZXJpZnk9IiR7UEFSQU1TX1NSQ19UTFNfVkVSSUZZfSIgXAogICAgICAgIC0tZGVzdC10bHMtdmVyaWZ5PSIke1BBUkFNU19ERVNUX1RMU19WRVJJRll9IiBcCiAgICAgICAgIiR7UEFSQU1TX1NPVVJDRV9JTUFHRV9VUkx9IiBcCiAgICAgICAgIiR7UEFSQU1TX0RFU1RJTkFUSU9OX0lNQUdFX1VSTH0iCmVsc2UKICAgICMgRnVuY3Rpb24gdG8gY29weSBtdWx0aXBsZSBpbWFnZXMuCiAgICBjb3B5aW1hZ2VzKCkgewogICAgICAgIGZpbGVuYW1lPSIke1dPUktTUEFDRVNfSU1BR0VTX1VSTF9QQVRIfS91cmwudHh0IgogICAgICAgIHdoaWxlIElGUz0gcmVhZCAtciBsaW5lIHx8IFsgLW4gIiRsaW5lIiBdCiAgICAgICAgZG8KICAgICAgICAgICAgY21kPSIiCiAgICAgICAgICAgIGZvciB1cmwgaW4gJGxpbmUKICAgICAgICAgICAgZG8KICAgICAgICAgICAgICAgIGNtZD0iJGNtZCAkdXJsIgogICAgICAgICAgICBkb25lCiAgICAgICAgICAgIHJlYWQgLXJhIFNPVVJDRSA8PDwiJHtjbWR9IgogICAgICAgICAgICBza29wZW8gY29weSAiJHtTT1VSQ0VbQF19IiAtLXNyYy10bHMtdmVyaWZ5PSIke1BBUkFNU19TUkNfVExTX1ZFUklGWX0iIC0tZGVzdC10bHMtdmVyaWZ5PSIke1BBUkFNU19ERVNUX1RMU19WRVJJRll9IgogICAgICAgICAgICBlY2hvICIkY21kIgogICAgICAgIGRvbmUgPCAiJGZpbGVuYW1lIgogICAgfQoKICAgIGNvcHlpbWFnZXMKZmkK" |base64 -d >"/scripts/skopeo-copy.sh"
        echo "/scripts/skopeo-results.sh"
        printf '%s' "IyEvdXNyL2Jpbi9lbnYgYmFzaAoKc2hvcHQgLXMgaW5oZXJpdF9lcnJleGl0CnNldCAtZXUgLW8gcGlwZWZhaWwKCnNvdXJjZSAiJChkaXJuYW1lICR7QkFTSF9TT1VSQ0VbMF19KS9jb21tb24uc2giCnNvdXJjZSAiJChkaXJuYW1lICR7QkFTSF9TT1VSQ0VbMF19KS9za29wZW8tY29tbW9uLnNoIgoKZnVuY3Rpb24gc2tvcGVvX2luc3BlY3QoKSB7CiAgICBsb2NhbCBpbWFnZT0iJDEiCiAgICBsb2NhbCB0bHNfdmVyaWZ5PSIkMiIKICAgIHNrb3BlbyBpbnNwZWN0ICR7U0tPUEVPX0RFQlVHX0ZMQUd9IFwKICAgICAgICAtLXRscy12ZXJpZnk9IiR7dGxzX3ZlcmlmeX0iIFwKICAgICAgICAtLWZvcm1hdD0ne3sgLkRpZ2VzdCB9fScgXAogICAgICAgICIke2ltYWdlfSIKfQoKcGhhc2UgIkV4dHJhY3RpbmcgJyR7UEFSQU1TX1NPVVJDRV9JTUFHRV9VUkx9JyBzb3VyY2UgaW1hZ2UgZGlnZXN0Igpzb3VyY2VfZGlnZXN0PSIkKHNrb3Blb19pbnNwZWN0ICIke1BBUkFNU19TT1VSQ0VfSU1BR0VfVVJMfSIgIiR7UEFSQU1TX1NSQ19UTFNfVkVSSUZZfSIpIgpwaGFzZSAiU291cmNlIGltYWdlIGRpZ2VzdCAnJHtzb3VyY2VfZGlnZXN0fSciCgpwaGFzZSAiRXh0cmFjdGluZyAnJHtQQVJBTVNfREVTVElOQVRJT05fSU1BR0VfVVJMfScgZGVzdGluYXRpb24gaW1hZ2UgZGlnZXN0IgpkZXN0aW5hdGlvbl9kaWdlc3Q9IiQoc2tvcGVvX2luc3BlY3QgIiR7UEFSQU1TX0RFU1RJTkFUSU9OX0lNQUdFX1VSTH0iICIke1BBUkFNU19ERVNUX1RMU19WRVJJRll9IikiCnBoYXNlICJEZXN0aW5hdGlvbiBpbWFnZSBkaWdlc3QgJyR7ZGVzdGluYXRpb25fZGlnZXN0fSciCgpwcmludGYgIiVzIiAiJHtzb3VyY2VfZGlnZXN0fSIgPiAiJHtSRVNVTFRTX1NPVVJDRV9ESUdFU1RfUEFUSH0iCnByaW50ZiAiJXMiICIke2Rlc3RpbmF0aW9uX2RpZ2VzdH0iID4gIiR7UkVTVUxUU19ERVNUSU5BVElPTl9ESUdFU1RfUEFUSH0iCg==" |base64 -d >"/scripts/skopeo-results.sh"
        ls /scripts/skopeo-*.sh;
        chmod +x /scripts/skopeo-*.sh;echo "Running Script /scripts/skopeo-copy.sh";
          /scripts/skopeo-copy.sh;echo "Running Script /scripts/skopeo-results.sh";
          /scripts/skopeo-results.sh;
      volumeMounts:
      - mountPath: /scripts
        name: scripts-dir
    volumes:
    - emptyDir: {}
      name: scripts-dir
    workspaces:
    - description: |
        For storing image urls in case we have more than one image to copy.
      name: images_url
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      tekton.dev/categories: CLI
      tekton.dev/displayName: Tekton CLI
      tekton.dev/pipelines.minVersion: 0.17.0
      tekton.dev/platforms: linux/amd64,linux/s390x,linux/ppc64le
      tekton.dev/tags: cli
    creationTimestamp: "2025-07-01T20:50:30Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.4"
    name: tkn
    namespace: vm-pipelines
    resourceVersion: "16198179"
    uid: 0925fa17-017f-4746-9126-fbfaddf7c7bf
  spec:
    description: This task performs operations on Tekton resources using tkn
    params:
    - default: gcr.io/tekton-releases/dogfooding/tkn@sha256:d17fec04f655551464a47dd59553c9b44cf660cc72dbcdbd52c0b8e8668c0579
      description: tkn CLI container image to run this task
      name: TKN_IMAGE
      type: string
    - default: tkn $@
      description: tkn CLI script to execute
      name: SCRIPT
      type: string
    - default:
      - --help
      description: tkn CLI arguments to run
      name: ARGS
      type: array
    steps:
    - args:
      - $(params.ARGS)
      computeResources: {}
      env:
      - name: HOME
        value: /tekton/home
      image: $(params.TKN_IMAGE)
      name: tkn
      script: |
        if [ "$(workspaces.kubeconfig.bound)" = "true" ] && [ -e $(workspaces.kubeconfig.path)/kubeconfig ]; then
          export KUBECONFIG="$(workspaces.kubeconfig.path)"/kubeconfig
        fi

        eval "$(params.SCRIPT)"
      securityContext:
        runAsNonRoot: true
        runAsUser: 65532
    workspaces:
    - description: An optional workspace that allows you to provide a .kube/config
        file for tkn to access the cluster. The file should be placed at the root
        of the Workspace with name kubeconfig.
      name: kubeconfig
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      openshift.io/installed-from: Tektonhub
      tekton.dev/categories: Security
      tekton.dev/displayName: trivy scanner
      tekton.dev/pipelines.minVersion: 0.12.1
      tekton.dev/platforms: linux/amd64,linux/arm64,linux/ppc64le,linux/390x
      tekton.dev/tags: CLI, trivy
    creationTimestamp: "2025-06-19T15:18:17Z"
    generation: 1
    labels:
      app.kubernetes.io/version: "0.2"
    name: trivy-scanner
    namespace: vm-pipelines
    resourceVersion: "11054134"
    uid: e4e4e168-3c7f-412d-ab9d-ff79a6e1f446
  spec:
    description: |-
      Trivy is a simple and comprehensive scanner for vulnerabilities in container images,file systems ,and Git repositories, as well as for configuration issues.
      This task can be used to scan for vulnenrabilities on the source code in stand alone mode.
    params:
    - description: The Arguments to be passed to Trivy command.
      name: ARGS
      type: array
    - default: docker.io/aquasec/trivy@sha256:944a044451791617cc0ed2ee4d1942a4f66b790d527fcd0575a6b399ccbc05a1
      description: Trivy scanner image to be used
      name: TRIVY_IMAGE
      type: string
    - description: Image or Path to be scanned by trivy.
      name: IMAGE_PATH
      type: string
    - default: "false"
      description: a flag enabling Air-Gapped mode
      name: AIR_GAPPED_ENABLED
      type: string
    steps:
    - args:
      - $(params.ARGS)
      computeResources: {}
      image: $(params.TRIVY_IMAGE)
      name: trivy-scan
      script: |
        #!/usr/bin/env sh
          cmd="trivy $* "
          if [ "$(params.AIR_GAPPED_ENABLED)" = "true" ]; then
            echo "Air-Gapped mode enabled"
            TRIVY_TEMP_DIR=$(mktemp -d)
            trivy --cache-dir "$TRIVY_TEMP_DIR" image --download-db-only
            tar -cf ./db.tar.gz -C "$TRIVY_TEMP_DIR/db" metadata.json trivy.db
            rm -rf "$TRIVY_TEMP_DIR"
            mkdir -p "$HOME"/.cache/trivy/db
            tar xvf ./db.tar.gz -C "$HOME"/.cache/trivy/db
            cmd="${cmd}--skip-update "
          fi
          cmd="${cmd}$(params.IMAGE_PATH)"
          echo "Running trivy task with command below"
          echo "$cmd"
          eval "$cmd"
      workingDir: $(workspaces.manifest-dir.path)
    workspaces:
    - name: manifest-dir
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    creationTimestamp: "2025-06-20T22:21:53Z"
    generation: 10
    name: virtctl-cli
    namespace: vm-pipelines
    resourceVersion: "15741595"
    uid: 30c47498-d130-4783-9f57-a777b3274641
  spec:
    description: Provides virtctl CLI
    params:
    - description: The Arguments to be passed to virtctl command.
      name: ARGS
      type: string
    - default: quay.io/linuxeroagrio/virtctl:4.19
      description: Virtctl image to be used
      name: VIRTCTL_IMAGE
      type: string
    steps:
    - computeResources: {}
      image: $(params.VIRTCTL_IMAGE)
      name: virtctl-cli
      script: |
        #!/usr/bin/env bash
        virtctl $(params.ARGS)
      workingDir: $(workspaces.objects.path)
    workspaces:
    - name: objects
      optional: true
- apiVersion: tekton.dev/v1
  kind: Task
  metadata:
    annotations:
      artifacthub.io/category: integration-delivery
      artifacthub.io/maintainers: |
        - name: KubeVirt Tekton tasks maintainers
          email: kubevirt-tekton-tasks@redhat.com
      artifacthub.io/provider: KubeVirt
      artifacthub.io/recommendations: |
        - url: https://kubevirt.io/
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"tekton.dev/v1","kind":"Task","metadata":{"annotations":{"artifacthub.io/category":"integration-delivery","artifacthub.io/maintainers":"- name: KubeVirt Tekton tasks maintainers\n  email: kubevirt-tekton-tasks@redhat.com\n","artifacthub.io/provider":"KubeVirt","artifacthub.io/recommendations":"- url: https://kubevirt.io/\n","tekton.dev/categories":"Automation","tekton.dev/displayName":"KubeVirt wait for VMI status","tekton.dev/pipelines.minVersion":"0.43.0","tekton.dev/platforms":"linux/amd64","tekton.dev/tags":"kubevirt"},"labels":{"app.kubernetes.io/version":"v0.24.0"},"name":"wait-for-vmi-status","namespace":"vm-pipelines"},"spec":{"description":"This tasks waits until KubeVirt virtual machine is in some  state. It can be used in pipeline where user needs to wait until e.g.  VM finish some installation.","params":[{"description":"Name of a VirtualMachineInstance to wait for.","name":"vmiName","type":"string"},{"default":"","description":"Namespace of a VirtualMachineInstance to wait for. (defaults to manifest namespace or active namespace)","name":"vmiNamespace","type":"string"},{"default":"","description":"A label selector expression to decide if the VirtualMachineInstance (VMI) is in a success state. Eg. \"status.phase == Succeeded\". It is evaluated on each VMI update and will result in this task succeeding if true.","name":"successCondition"},{"default":"","description":"A label selector expression to decide if the VirtualMachineInstance (VMI) is in a failed state. Eg. \"status.phase in (Failed, Unknown)\". It is evaluated on each VMI update and will result in this task failing if true.","name":"failureCondition"}],"steps":[{"command":["entrypoint"],"env":[{"name":"COMMAND","value":"wait-for-vmi-status"},{"name":"VMI_NAME","value":"$(params.vmiName)"},{"name":"VMI_NAMESPACE","value":"$(params.vmiNamespace)"},{"name":"SUCCESS_CONDITION","value":"$(params.successCondition)"},{"name":"FAILURE_CONDITION","value":"$(params.failureCondition)"}],"image":"quay.io/kubevirt/tekton-tasks:v0.24.0","name":"wait-for-vmi-status"}]}}
      tekton.dev/categories: Automation
      tekton.dev/displayName: KubeVirt wait for VMI status
      tekton.dev/pipelines.minVersion: 0.43.0
      tekton.dev/platforms: linux/amd64
      tekton.dev/tags: kubevirt
    creationTimestamp: "2025-06-24T17:39:11Z"
    generation: 1
    labels:
      app.kubernetes.io/version: v0.24.0
    name: wait-for-vmi-status
    namespace: vm-pipelines
    resourceVersion: "13123785"
    uid: 358ea850-dfac-46b6-9fce-2a277e9c43da
  spec:
    description: This tasks waits until KubeVirt virtual machine is in some  state.
      It can be used in pipeline where user needs to wait until e.g.  VM finish some
      installation.
    params:
    - description: Name of a VirtualMachineInstance to wait for.
      name: vmiName
      type: string
    - default: ""
      description: Namespace of a VirtualMachineInstance to wait for. (defaults to
        manifest namespace or active namespace)
      name: vmiNamespace
      type: string
    - default: ""
      description: A label selector expression to decide if the VirtualMachineInstance
        (VMI) is in a success state. Eg. "status.phase == Succeeded". It is evaluated
        on each VMI update and will result in this task succeeding if true.
      name: successCondition
      type: string
    - default: ""
      description: A label selector expression to decide if the VirtualMachineInstance
        (VMI) is in a failed state. Eg. "status.phase in (Failed, Unknown)". It is
        evaluated on each VMI update and will result in this task failing if true.
      name: failureCondition
      type: string
    steps:
    - command:
      - entrypoint
      computeResources: {}
      env:
      - name: COMMAND
        value: wait-for-vmi-status
      - name: VMI_NAME
        value: $(params.vmiName)
      - name: VMI_NAMESPACE
        value: $(params.vmiNamespace)
      - name: SUCCESS_CONDITION
        value: $(params.successCondition)
      - name: FAILURE_CONDITION
        value: $(params.failureCondition)
      image: quay.io/kubevirt/tekton-tasks:v0.24.0
      name: wait-for-vmi-status
kind: List
metadata:
  resourceVersion: ""
